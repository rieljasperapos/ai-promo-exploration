import { AtlasViewer } from './viewer.js';
export const isNode = typeof process !== 'undefined' && process.versions && process.versions.node;
export class BaseAtlasClass {
    constructor(viewer) {
        if (viewer === undefined) {
            this.viewer = getEnvViewer();
        }
        else {
            // Back-compatibility. Remove in 1.0.
            if (viewer.projects !== undefined) {
                this.viewer = viewer.viewer;
            }
            else {
                this.viewer = viewer;
            }
        }
    }
    /**
     * returns the object's information; this may be undefined
     */
    get attr() {
        return this._attr;
    }
    /**
     * Fetches basic information about the object.
     * By default, this caches the call; if you want to
     * bust the cache, pass `true` as the first argument.
     * This immediately.
     *
     * @param bustCache Whether to refetch the relevant information
     * @returns A promise that resolves to the organization info.
     */
    fetchAttributes(bustCache = false) {
        if (!bustCache && this.attributePromise !== undefined) {
            return this.attributePromise;
        }
        this.attributePromise = this.viewer
            .apiCall(this.endpoint(), 'GET')
            .then((attr) => {
            this._attr = attr;
            return attr;
        });
        return this.attributePromise;
    }
    /**
     * Loads the information associated with the class, removing any
     * existing caches.
     *
     *
     *
     * @returns a LoadedObject instance of the class that is guaranteed to
     *  have its `attr` slot populated with appropriate information.
     *
     * @example
     *  const loadedProject = await (new AtlasProject(projectId)).withLoadedAttributes()
     *
     *  // OR, in cases where we want to do stuff immediately with the project and ensure
     *  // that later calls there don't double-fetch information.
     *
     *  const project = new AtlasProject(projectId)
     *
     *  // do stuff right away.
     *  const projection = new AtlasProjection(projectionId, {project: project})
     *  const loadedProjection = await projection.withLoadedAttributes()
     *  // do stuff with loadedProjection
     *
     *
     */
    async withLoadedAttributes() {
        await this.fetchAttributes(true);
        return this;
    }
    async apiCall(endpoint, method, payload = null, headers = null) {
        // make an API call
        return this.viewer.apiCall(endpoint, method, payload, headers);
    }
}
let viewer = undefined;
export function getEnvViewer() {
    if (viewer === undefined) {
        console.warn('CREATING USER FROM ENV');
        viewer = new AtlasViewer({ useEnvToken: true });
    }
    return viewer;
}
export class AtlasUser extends BaseAtlasClass {
    /*
    An AtlasUser is a registered user. The class contains
    both information about the user and the credentials
    needed to make API calls.
    */
    constructor(...args) {
        // For the time being, the AtlasUser can be constructed to created a viewer inside of it.
        // As time goes on, this will be deprecated.
        if (args[0] instanceof AtlasViewer) {
            super(args[0]);
        }
        else {
            const viewer = new AtlasViewer(...args);
            super(viewer);
        }
    }
    endpoint() {
        return '/v1/user/';
    }
    get anonymous() {
        return this.viewer.anonymous;
    }
    get apiLocation() {
        return this.viewer.apiLocation;
    }
    /**
     *
     * @returns All projects that the user has access to.
     */
    async projects() {
        const all_projects = [];
        for (const org of await this.organizations()) {
            const projects = await org.projects();
            all_projects.push(...projects);
        }
        return all_projects;
    }
    /**
     *
     * @param role return only organizations where the user has this role (default: null, return all organizations)
     * @returns A list of organizations where the user has the specified role
     */
    async organizations(role = null) {
        let organizations = (await this.fetchAttributes()).organizations || [];
        if (role !== null) {
            organizations = organizations.filter((org) => org.access_role === role);
        }
        const AtlasOrganization = await import('./organization.js').then((d) => d.AtlasOrganization);
        return organizations.map((org) => new AtlasOrganization(org.organization_id, this.viewer));
    }
}
