import type { Schema, Table } from 'apache-arrow';
import { BaseAtlasClass } from './user.js';
import { AtlasIndex } from './index.js';
import { AtlasViewer } from './viewer.js';
import * as Atlas from './global.js';
import { components } from './type-gen/openapi.js';
type UUID = string;
export declare function load_project(options: Atlas.LoadProjectOptions): AtlasDataset;
type IndexCreateOptions = {
    project_id: UUID;
    index_name: string;
    indexed_field?: string;
    colorable_fields?: string[];
    multilingual?: boolean;
    build_topic_model?: boolean;
    topic_label_field?: string;
    duplicate_detection?: boolean;
};
/**
 * An AtlasDataset represents a single mutable dataset in Atlas. It provides an
 * interfaces to upload, update, and delete data, as well as create and delete
 * indices which handle specific views.
 */
export declare class AtlasDataset extends BaseAtlasClass<components['schemas']['Project']> {
    _indices: AtlasIndex[];
    _schema?: Schema | null;
    id: UUID;
    /**
     *
     * @param id The project's unique UUID. To create a new project or fetch
     * an existing project, use the create_project or load_project functions.
     * @param user An existing AtlasUser object. If not provided, a new one will be created.
     *
     * @returns An AtlasDataset object.
     */
    constructor(id: UUID | string, viewer?: AtlasViewer);
    /**
     *
     * @returns A list of projection summaries, sorted so that the first is
     * the most useable (defined as ready and newest)
     */
    projectionSummaries(): Promise<{
        id: string;
        projection_name: string;
        ready: boolean;
        hyperparameters: Record<string, unknown>;
        atom_strategies: string[];
        created_timestamp: string;
        updated_timestamp: string;
        thumbnail?: string | undefined;
        og_image?: string | undefined;
    }[]>;
    delete(): Promise<string | any[] | Record<string, any> | Uint8Array | Table<any> | null>;
    private clear;
    wait_for_lock(): Promise<void>;
    protected endpoint(): string;
    indices(): Promise<AtlasIndex[]>;
    /**
     * Updates all indices associated with a project.
     *
     * @param rebuild_topic_models If true, rebuilds topic models for all indices.
     */
    update_indices(rebuild_topic_models?: boolean): Promise<void>;
    add_text(records: Record<string, string>[]): Promise<void>;
    add_embeddings(): Promise<void>;
    /**
     *
     * @param ids A list of identifiers to fetch from the server.
     */
    fetch_ids(ids?: string[]): Promise<Record<string, Record<string, any>>>;
    /**
     * This should be preferred over createIndex, as it uses the actual
     * up-to-date types. Note that it is definitely possible to pass a
     * malformed but type-compliant object. (E.g., specifying no embedding field
     * but also specifying a model.)
     *
     * @param options See types for options.
     * @returns an AtlasIndex object based on the new arguments.
     */
    createIndexRaw(options: Partial<components['schemas']['CreateAtlasIndexRequest']> & {
        indexed_field: string;
    }): Promise<AtlasIndex>;
    /**
     * Prefer createIndexRaw, which has better syncing of types
     * @deprecated
     * @param options
     * @returns
     */
    createIndex(options: Omit<IndexCreateOptions, 'project_id'>): Promise<AtlasIndex>;
    delete_data(ids: string[]): Promise<void>;
    validate_metadata(): void;
    get schema(): Schema<any> | null | undefined;
    uploadArrow(table: Table | Uint8Array): Promise<void>;
}
export {};
