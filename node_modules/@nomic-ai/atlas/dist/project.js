import { tableToIPC, tableFromJSON, tableFromIPC } from 'apache-arrow';
import { BaseAtlasClass } from './user.js';
import { AtlasIndex } from './index.js';
export function load_project(options) {
    throw new Error('Not implemented');
}
const createIndexTextDefaults = {
    index_name: 'New index',
    indexed_field: 'document',
    colorable_fields: [],
    atomizer_strategies: ['document', 'charchunk'],
    geometry_strategies: [['document']],
    model: 'nomic-embed-text-v1.5',
    model_hyperparameters: JSON.stringify({
        dataset_buffer_size: 1000,
        batch_size: 20,
        polymerize_by: 'charchunk',
        norm: 'both',
    }),
    nearest_neighbor_index: 'HNSWIndex',
    nearest_neighbor_index_hyperparameters: JSON.stringify({
        space: 'l2',
        ef_construction: 100,
        M: 16,
    }),
    projection: 'NomicProject',
    projection_hyperparameters: JSON.stringify({
        n_neighbors: 15,
        n_epochs: 50,
        spread: 1,
    }),
    topic_model_hyperparameters: JSON.stringify({
        build_topic_model: true,
        community_description_target_field: null,
        cluster_method: 'fast',
        enforce_topic_hierarchy: false,
    }),
    duplicate_detection_hyperparameters: JSON.stringify({
        tag_duplicates: false,
        duplicate_cutoff: 0.1,
    }),
};
/**
 * An AtlasDataset represents a single mutable dataset in Atlas. It provides an
 * interfaces to upload, update, and delete data, as well as create and delete
 * indices which handle specific views.
 */
export class AtlasDataset extends BaseAtlasClass {
    /**
     *
     * @param id The project's unique UUID. To create a new project or fetch
     * an existing project, use the create_project or load_project functions.
     * @param user An existing AtlasUser object. If not provided, a new one will be created.
     *
     * @returns An AtlasDataset object.
     */
    constructor(id, viewer) {
        super(viewer);
        this._indices = [];
        // check if id is a valid UUID
        const uuidPattern = /[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}/;
        this.id = id;
        if (!id.toLowerCase().match(uuidPattern)) {
            // throw new Error(`${id} is not a valid UUID.`);
            this.id = id;
            this.fetchAttributes().then((i) => (this.id = i.id));
        }
    }
    /**
     *
     * @returns A list of projection summaries, sorted so that the first is
     * the most useable (defined as ready and newest)
     */
    async projectionSummaries() {
        const projections = [];
        const info = await this.fetchAttributes();
        for (const index of info.atlas_indices) {
            for (const projection of index.projections) {
                projections.push(projection);
            }
        }
        // sort from newest to oldest
        // Put ready projections first
        projections.sort((a, b) => {
            if (a.ready && !b.ready)
                return -1;
            if (!a.ready && b.ready)
                return 1;
            return (new Date(b.created_timestamp).getTime() -
                new Date(a.created_timestamp).getTime());
        });
        return projections;
    }
    async delete() {
        const value = await this.apiCall(`/v1/project/remove`, 'POST', {
            project_id: this.id,
        });
        return value;
    }
    clear() {
        this.attributePromise = undefined;
        this._schema = undefined;
        this._indices = [];
    }
    async wait_for_lock() {
        return new Promise((resolve, reject) => {
            const interval = setInterval(async () => {
                // Create a new project to clear the cache.
                const renewed = new AtlasDataset(this.id, this.viewer);
                const info = await renewed.fetchAttributes();
                if (info.insert_update_delete_lock === false) {
                    clearInterval(interval);
                    // Clear the cache.
                    this.clear();
                    resolve();
                }
            }, 2000);
        });
    }
    endpoint() {
        return `/v1/project/${this.id}`;
    }
    async indices() {
        if (this._indices.length > 0) {
            return this._indices;
        }
        const { atlas_indices } = await this.fetchAttributes();
        if (atlas_indices === undefined) {
            return [];
        }
        const options = { project: this };
        this._indices = atlas_indices.map((d) => new AtlasIndex(d['id'], this.viewer, options));
        return this._indices;
    }
    /**
     * Updates all indices associated with a project.
     *
     * @param rebuild_topic_models If true, rebuilds topic models for all indices.
     */
    async update_indices(rebuild_topic_models = false) {
        throw new Error('Update_indices has been deprecated: please run `createIndex` on an existing project instead.');
    }
    async add_text(records) {
        const table = tableFromJSON(records);
        await this.uploadArrow(table);
    }
    async add_embeddings() {
        // TODO: implement
    }
    /**
     *
     * @param ids A list of identifiers to fetch from the server.
     */
    async fetch_ids(ids) {
        if (ids === undefined) {
            return {};
        }
        const response = await this.apiCall('/v1/project/data/get', 'POST', { project_id: this.id, datum_ids: ids }, null);
        return response;
    }
    /**
     * This should be preferred over createIndex, as it uses the actual
     * up-to-date types. Note that it is definitely possible to pass a
     * malformed but type-compliant object. (E.g., specifying no embedding field
     * but also specifying a model.)
     *
     * @param options See types for options.
     * @returns an AtlasIndex object based on the new arguments.
     */
    async createIndexRaw(options) {
        // The default options for this request are very long, so we use them.
        // Then we override them with the user's options, and finally guarantee
        // that the project_id is set.
        const fields = {
            ...createIndexTextDefaults,
            ...options,
            project_id: this.id,
        };
        const response = await this.apiCall('/v1/project/index/create', 'POST', fields);
        const id = response;
        return new AtlasIndex(id, this.viewer, { project: this });
    }
    /**
     * Prefer createIndexRaw, which has better syncing of types
     * @deprecated
     * @param options
     * @returns
     */
    async createIndex(options) {
        const info = await this.fetchAttributes();
        const isText = info.modality === 'text';
        const fields = {
            project_id: this.id,
            index_name: options.index_name ?? 'New index',
            indexed_field: options.indexed_field ?? null,
            colorable_fields: options.colorable_fields ?? [],
            atomizer_strategies: isText ? ['document', 'charchunk'] : null,
            geometry_strategies: isText ? [['document']] : null,
            model: isText
                ? options.multilingual
                    ? 'NomicEmbedMultilingual'
                    : 'NomicEmbed'
                : null,
            model_hyperparameters: isText
                ? JSON.stringify({
                    dataset_buffer_size: 1000,
                    batch_size: 20,
                    polymerize_by: 'charchunk',
                    norm: 'both',
                })
                : null,
            nearest_neighbor_index: 'HNSWIndex',
            nearest_neighbor_index_hyperparameters: JSON.stringify({
                space: 'l2',
                ef_construction: 100,
                M: 16,
            }),
            projection: 'NomicProject',
            projection_hyperparameters: JSON.stringify({
                n_neighbors: 15,
                n_epochs: 50,
                spread: 1,
            }),
            topic_model_hyperparameters: JSON.stringify({
                build_topic_model: options.build_topic_model ?? false,
                community_description_target_field: options.topic_label_field ?? null,
                cluster_method: 'fast',
                enforce_topic_hierarchy: false,
            }),
            duplicate_detection_hyperparameters: isText
                ? JSON.stringify({
                    tag_duplicates: options.duplicate_detection ?? false,
                    duplicate_cutoff: 0.1,
                })
                : null,
        };
        const response = await this.apiCall('/v1/project/index/create', 'POST', fields);
        const id = response;
        return new AtlasIndex(id, this.viewer, { project: this });
    }
    async delete_data(ids) {
        // TODO: untested
        // const info = await this.info
        await this.viewer.apiCall('/v1/project/data/delete', 'POST', {
            project_id: this.id,
            datum_ids: ids,
        });
    }
    validate_metadata() {
        // validate metadata
    }
    /*  async create_projection(options: IndexCreateOptions) : Promise<AtlasProjection> {
      await
    } */
    get schema() {
        if (this._schema === undefined) {
            // this.update_info()
        }
        return this._schema;
    }
    async uploadArrow(table) {
        if (table instanceof Uint8Array) {
            table = tableFromIPC(table);
        }
        table.schema.metadata.set('project_id', this.id);
        table.schema.metadata.set('on_id_conflict_ignore', JSON.stringify(true));
        const data = tableToIPC(table, 'file');
        await this.apiCall(`/v1/project/data/add/arrow`, 'POST', data);
    }
}
