import { BaseAtlasClass } from './user.js';
import type { AtlasUser } from './user.js';
import { AtlasDataset } from './project.js';
import type { AtlasIndex } from './index.js';
import { AtlasViewer } from './viewer.js';
import type { components } from './type-gen/openapi.js';
export type ProjectGetInfo = components['schemas']['Project'];
type UUID = string;
export type DeleteTagRequest = {
    tag_id: UUID;
};
/**
 * Options for initializing a projection.
 */
type ProjectionInitializationOptions = {
    project?: AtlasDataset;
    index?: AtlasIndex;
    project_id?: UUID;
    user?: AtlasUser;
};
type TagResponse = {
    tag_id: UUID;
    tag_definition_id: string;
    tag_name?: string;
    user_id?: string;
    dsl_rule?: string;
};
type TagComponent = Record<string, any>;
export type TagMaskOperation = 'OR' | 'AND' | 'UPSERT' | 'NOOP' | 'ALLSET_TRUE' | 'ALLSET_FALSE';
type TagComposition = TagComponent | ['OR' | 'AND' | 'NOT' | 'ANY' | 'ALL', ...TagComposition[]];
type TagRequestOptions = {
    tag_name: string;
    dsl_rule: TagComposition;
    tag_id: UUID;
};
type RoboTagOptions = {
    tag_id: UUID;
};
export type UpdateTagOptions = {
    tag_id: UUID;
    dsl_rule: TagComposition;
    tag_definition_id: string;
    tag_name: never;
} | {
    tag_id: UUID;
    tag_name: string;
    tag_definition_id: never;
    dsl_rule: never;
};
export type UpdateTagMaskOptions = {
    tag_id: UUID;
    tag_definition_id: string;
    complete: boolean | undefined;
};
type CreateTagOptions = {
    tag_name: string;
    dsl_rule: TagComposition;
    tag_definition_id: string;
};
type TagStatus = {
    is_complete: boolean;
};
export declare class AtlasProjection extends BaseAtlasClass<components['schemas']['ProjectionResponse']> {
    id: UUID;
    /**
     * A projection is a map in Atlas; it represents a snapshot 2d view of a dataset
     * at a point in time. Every projection belongs to a Dataset.
     */
    _project?: AtlasDataset;
    protected project_id?: UUID;
    _project_id_promise?: Promise<UUID>;
    _index?: AtlasIndex;
    /**
     *
     * @param id The UUID of the projection to retrieve.
     * @param user The user object to query with.
     * @param options Options for initializing the projection.
     */
    constructor(id: UUID, user?: AtlasUser | AtlasViewer, options?: ProjectionInitializationOptions);
    /**
     * @returns the UUID of the dataset that this projection belongs to.
     */
    datasetId(): Promise<UUID>;
    createTag(options: CreateTagOptions): Promise<TagResponse>;
    updateTag(options: UpdateTagOptions): Promise<TagResponse>;
    deleteTag(options: DeleteTagRequest): Promise<void>;
    getTags(): Promise<Array<TagResponse>>;
    getTagStatus(options: TagRequestOptions): Promise<TagStatus>;
    updateTagMask(bitmask_bytes: Uint8Array, options: UpdateTagMaskOptions): Promise<void>;
    roboTag(options: RoboTagOptions): Promise<void>;
    _schema: Uint8Array | null;
    schema(): Promise<Uint8Array>;
    project(): Promise<AtlasDataset>;
    index(): Promise<AtlasIndex>;
    atomInformation(ids: string[] | number[] | bigint[]): Promise<any>;
    /**
     * @returns the URL for the quadtree root for this projection.
     * 'public' may be be added in fetching.
     */
    get quadtree_root(): string;
    protected endpoint(): string;
    /**
     *
     * @param param0 an object with keys k (number of numbers) and queries (list of vectors, where each one is the length of the embedding space).
     * @returns A list of entries in sorted order, where each entry is a list of neighbors including distances in the `_distance` field.
     */
    nearest_neighbors_by_vector({ k, queries, }: Omit<components['schemas']['EmbeddingNeighborRequest'], 'atlas_index_id'>): Promise<Record<string, any>>;
}
export {};
