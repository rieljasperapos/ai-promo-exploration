import { BaseAtlasClass } from './general.js';
import type { AtlasUser } from './user.js';
import { AtlasProject } from './project.js';
import type { AtlasIndex } from './index.js';
type UUID = string;
type ProjectionInitializationOptions = {
    project?: AtlasProject;
    index?: AtlasIndex;
    project_id?: UUID;
    user?: AtlasUser;
};
type TagResponse = {
    tag_id: UUID;
    tag_definition_id: string;
    tag_name?: string;
    user_id?: string;
    dsl_rule?: string;
};
type TagComponent = Record<string, any>;
type TagComposition = TagComponent | ['OR' | 'AND' | 'NOT' | 'ANY' | 'ALL', ...TagComposition[]];
type TagRequestOptions = {
    tag_name: string;
    dsl_rule: TagComposition;
    tag_id: UUID;
};
export type UpdateTagOptions = {
    tag_id: UUID;
    dsl_rule: TagComposition;
    tag_definition_id: string;
    tag_name: never;
} | {
    tag_id: UUID;
    tag_name: string;
    tag_definition_id: never;
    dsl_rule: never;
};
export type UpdateTagMaskOptions = {
    tag_id: UUID;
    tag_definition_id: string;
    complete: boolean | undefined;
};
type CreateTagOptions = {
    tag_name: string;
    dsl_rule: TagComposition;
    tag_definition_id: string;
};
type TagStatus = {
    is_complete: boolean;
};
export declare class AtlasProjection extends BaseAtlasClass {
    id: UUID;
    _project?: AtlasProject;
    project_id: UUID;
    _index?: AtlasIndex;
    private _info?;
    constructor(id: UUID, user?: AtlasUser, options?: ProjectionInitializationOptions);
    createTag(options: CreateTagOptions): Promise<TagResponse>;
    updateTag(options: UpdateTagOptions): Promise<TagResponse>;
    deleteTag(options: TagRequestOptions): Promise<void>;
    getTags(): Promise<Array<TagResponse>>;
    getTagStatus(options: TagRequestOptions): Promise<TagStatus>;
    updateTagMask(bitmask_bytes: Uint8Array, options: UpdateTagMaskOptions): Promise<void>;
    _schema: Uint8Array | null;
    schema(): Promise<Uint8Array>;
    project(): Promise<AtlasProject>;
    index(): Promise<AtlasIndex>;
    atomInformation(ids: string[] | number[] | bigint[]): Promise<any>;
    /**
     * @returns the URL for the quadtree root for this projection.
     * 'public' may be be added in fetching.
     */
    get quadtree_root(): string;
    info(): Promise<Record<string, any>>;
}
export {};
