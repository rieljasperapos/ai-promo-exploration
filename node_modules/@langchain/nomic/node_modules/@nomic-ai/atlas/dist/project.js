import { tableToIPC, tableFromJSON, tableFromIPC } from 'apache-arrow';
import { AtlasIndex } from './index.js';
// get the API key from the node environment
import { BaseAtlasClass } from './general.js';
export function load_project(options) {
    throw new Error('Not implemented');
}
/**
 * An AtlasProject represents a single mutable dataset in Atlas. It provides an
 * interfaces to upload, update, and delete data, as well as create and delete
 * indices which handle specific views.
 */
export class AtlasProject extends BaseAtlasClass {
    /**
     *
     * @param id The project's unique UUID. To create a new project or fetch
     * an existing project, use the create_project or load_project functions.
     * @param user An existing AtlasUser object. If not provided, a new one will be created.
     *
     * @returns An AtlasProject object.
     */
    constructor(id, user) {
        super(user);
        this._indices = [];
        // check if id is a valid UUID
        const uuidPattern = /[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}/;
        this.id = id;
        if (!id.toLowerCase().match(uuidPattern)) {
            // throw new Error(`${id} is not a valid UUID.`);
            this.id = id;
            this.info().then((i) => (this.id = i.project_id));
        }
    }
    async projectionSummaries() {
        // Returns a list of projection summaries, sorted so that the first is
        // the most useable (defined as ready and newest)
        const projections = [];
        const info = await this.info();
        for (const index of info.atlas_indices) {
            for (const projection of index.projections) {
                projections.push(projection);
            }
        }
        // sort from newest to oldest
        // Put ready projections first
        projections.sort((a, b) => {
            if (a.ready && !b.ready)
                return -1;
            if (!a.ready && b.ready)
                return 1;
            return (new Date(b.created_timestamp).getTime() -
                new Date(a.created_timestamp).getTime());
        });
        return projections;
    }
    async apiCall(endpoint, method, payload = null, headers = null, options = {}) {
        const fixedEndpoint = await this._fixEndpointURL(endpoint);
        return this.user.apiCall(fixedEndpoint, method, payload, headers, options);
    }
    async delete() {
        const value = await this.apiCall(`/v1/project/remove`, 'POST', {
            project_id: this.id,
        });
        return value;
    }
    clear() {
        this._info = undefined;
        this._schema = undefined;
        this._indices = [];
    }
    async wait_for_lock() {
        return new Promise((resolve, reject) => {
            const interval = setInterval(async () => {
                // Create a new project to clear the cache.
                const renewed = new AtlasProject(this.id, this.user);
                const info = (await renewed.info());
                if (info.insert_update_delete_lock === false) {
                    clearInterval(interval);
                    // Clear the cache.
                    this.clear();
                    resolve();
                }
            }, 2000);
        });
    }
    project_info() {
        throw new Error(`This method is deprecated. Use info() instead.`);
    }
    info() {
        if (this._info !== undefined) {
            return this._info;
        }
        // This call must be on the underlying user object, not the project object,
        // because otherwise it will infinitely in some downstream calls.
        // stored as a promise so that we don't make multiple calls to the server
        this._info = this.user
            // Try the public route first
            .apiCall(`/v1/project/${this.id}`, 'GET');
        return this._info;
    }
    async _fixEndpointURL(endpoint) {
        // Don't mandate starting with a slash
        if (!endpoint.startsWith('/')) {
            console.warn(`DANGER: endpoint ${endpoint} doesn't start with a slash`);
            endpoint = '/' + endpoint;
        }
        return endpoint;
    }
    async indices() {
        if (this._indices.length > 0) {
            return this._indices;
        }
        const { atlas_indices } = (await this.info());
        console.log(await this.info(), atlas_indices, 'INFO');
        if (atlas_indices === undefined) {
            return [];
        }
        const options = { project: this };
        this._indices = atlas_indices.map((d) => new AtlasIndex(d['id'], this.user, options));
        return this._indices;
    }
    /**
     * Updates all indices associated with a project.
     *
     * @param rebuild_topic_models If true, rebuilds topic models for all indices.
     */
    async update_indices(rebuild_topic_models = false) {
        await this.apiCall(`/v1/project/update_indices`, 'POST', {
            project_id: this.id,
            rebuild_topic_models: rebuild_topic_models,
        });
    }
    async add_text(records) {
        const table = tableFromJSON(records);
        await this.uploadArrow(table);
    }
    async add_embeddings() {
        // TODO: implement
    }
    /**
     *
     * @param ids A list of identifiers to fetch from the server.
     */
    async fetch_ids(ids) {
        throw new Error('Not implemented');
    }
    async createIndex(options) {
        const info = await this.info();
        const isText = info.modality === 'text';
        // TODO: Python version has a number of asserts here - should we replicate?
        const fields = {
            project_id: this.id,
            index_name: options.index_name ?? 'New index',
            indexed_field: options.indexed_field ?? null,
            colorable_fields: options.colorable_fields ?? [],
            atomizer_strategies: isText ? ['document', 'charchunk'] : null,
            geometry_strategies: isText ? [['document']] : null,
            model: isText
                ? options.multilingual
                    ? 'NomicEmbedMultilingual'
                    : 'NomicEmbed'
                : null,
            model_hyperparameters: isText
                ? JSON.stringify({
                    dataset_buffer_size: 1000,
                    batch_size: 20,
                    polymerize_by: 'charchunk',
                    norm: 'both',
                })
                : null,
            nearest_neighbor_index: 'HNSWIndex',
            nearest_neighbor_index_hyperparameters: JSON.stringify({
                space: 'l2',
                ef_construction: 100,
                M: 16,
            }),
            projection: 'NomicProject',
            projection_hyperparameters: JSON.stringify({
                n_neighbors: 64,
                n_epochs: 64,
                spread: 1,
            }),
            topic_model_hyperparameters: JSON.stringify({
                build_topic_model: options.build_topic_model ?? false,
                community_description_target_field: options.topic_label_field ?? null,
                cluster_method: 'fast',
                enforce_topic_hierarchy: false,
            }),
            duplicate_detection_hyperparameters: isText
                ? JSON.stringify({
                    duplicate_detection: options.duplicate_detection ?? false,
                    duplicate_threshold: 0.1,
                })
                : null,
        };
        const response = await this.apiCall('/v1/project/index/create', 'POST', fields);
        const id = response;
        return new AtlasIndex(id, this.user, { project: this });
    }
    async delete_data(ids) {
        // TODO: untested
        // const info = await this.info
        await this.user.apiCall('/v1/project/data/delete', 'POST', {
            project_id: this.id,
            datum_ids: ids,
        });
    }
    validate_metadata() {
        // validate metadata
    }
    /*  async create_projection(options: IndexCreateOptions) : Promise<AtlasProjection> {
      await
    } */
    get schema() {
        if (this._schema === undefined) {
            // this.update_info()
        }
        return this._schema;
    }
    async uploadArrow(table) {
        if (table instanceof Uint8Array) {
            table = tableFromIPC(table);
        }
        table.schema.metadata.set('project_id', this.id);
        table.schema.metadata.set('on_id_conflict_ignore', JSON.stringify(true));
        const data = tableToIPC(table, 'file');
        await this.apiCall(`/v1/project/data/add/arrow`, 'POST', data);
    }
}
